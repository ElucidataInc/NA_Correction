from data_validation import DataValidator
import constants as const


class ConfigDataValidator(object):
    """
    This class takes in config file as input and 
    validates the data using DataValidator class.
    Config file has the following information:
        
        1. path of the file to be validated.
        2. required columns to be present in the file.
        3. list of checks that are to be performed on the file.
        4. State values that are to be recorded when a particular check fails.
        5. Which states are considered to be Warning states \
        (rest are assumed to be errors).
        6. What action to be performed for a particular warning state.
        7. Developer specific checks that are to be performed.
    """

    def __init__(self, temp_dict=None):

        self.check_config(temp_dict)
        self.dict = self.get_config(temp_dict)
        self.path = self.dict[const.DICT_FILE_PATH]
        self.set_config()
        self.dv = DataValidator(self.path,
                                self.dict[const.DICT_REQUIRED_COLUMN])
        self.report = None
        self.logs = None

    def check_config(self,temp_dict):
        """
        this functions checks the dictionary provied for the config
        is valid or not. 
        
        #TO-DO: Add more checks.
        :param temp_dict: 
        """

        if not isinstance(temp_dict, dict):
            raise TypeError(const.SHOULD_BE_DICT)

    def get_config(self, temp_dict=None):
        """
        This function takes in the dictionary as input.
        If the developer doesn't provide a dictionary while creating 
        instance of this class, this method will handle the situation 
        and returns an empty dictionary for the class to process.
        
         TO-DO: Can remove this method and raise an error here 
         itself as the file_path doesn't exist 
        :param temp_dict: 
        """
        if temp_dict:
            return temp_dict
        else:
            return const.EMPTY_CONFIG_DICT

    def set_config(self):
        """
        This function parses the config dictionary and 
        configures constants accordingly both the warning states
        and states that have to be raised by each function.
        """
        self.set_warnings()
        self.set_function_states()

    def set_warnings(self):
        """
        This function sets the states globally according to
        the states present in dict['warnings'].
        All the states present in the dict['warnings'] are considered
        as warning states and must have
        one of the three in-built actions
            1. Drop Row as  'DROP'
            2. Fill with NA as 'FILLNA'
            3. Stop the validation as 'Stop_Tool'
            
        'warnings' :    {
                            state_1:    action_1,
                            state_2:    action_2,
                        }
        """
        const.WARNING_STATE = {}
        for state in self.dict[const.DICT_WARNINGS]:
            if state in const.WARNING_STATE:
                raise Exception(const.SAME_STATE_ERROR + state)
            const.WARNING_STATE[state] = self.dict[const.DICT_WARNINGS][state]

    def set_function_states(self):
        """
        This function sets the states for checks to be validated
        
        When a particular in-built function is found in the dictionary, 
        a value should also be present which denotes the state that is
         recorded if the function fails.
        """
        if const.MISSING_DATA in self.dict[const.DICT_FUNCTIONS].keys():
            const.MISSING_STATE = self.dict[const.DICT_FUNCTIONS]\
                [const.MISSING_DATA][const.DICT_STATE]

        if const.DUPLICATE in self.dict[const.DICT_FUNCTIONS].keys():
            const.DUPLICATE_STATE = self.dict[const.DICT_FUNCTIONS]\
                [const.DUPLICATE][const.DICT_STATE]

        if const.NUMERICAL in self.dict[const.DICT_FUNCTIONS].keys():
            const.INTENSITY_STATE_NEGATIVE = self.dict[const.DICT_FUNCTIONS]\
                                [const.NUMERICAL][const.DICT_NEGATIVE_STATE]
            const.INTENSITY_STATE_INVALID = self.dict[const.DICT_FUNCTIONS]\
                                [const.NUMERICAL][const. DICT_INVALID_STATE]

        if const.CHEMICAL_FORMULA in self.dict[const.DICT_FUNCTIONS].keys():
            const.FORMULA_INVALID_STATE = self.dict[const.DICT_FUNCTIONS]\
                                [const.CHEMICAL_FORMULA][const.DICT_STATE]

        if const.VALUE_IN_CONSTANT in self.dict[const.DICT_FUNCTIONS].keys():
            temp_state = self.dict[const.DICT_FUNCTIONS]\
                [const.VALUE_IN_CONSTANT][const.DICT_STATE]
            const.VALUE_IN_CONSTANT_INVALID_STATE = temp_state

        if const.PATTERN_MATCH in self.dict[const.DICT_FUNCTIONS].keys():
            const.PATTERN_INVALID_STATE = self.dict[const.DICT_FUNCTIONS]\
                [const.PATTERN_MATCH][const.DICT_STATE]

    def validate(self):
        """
        This function validates all the functions by calling 
        the respective functions accordingly
         All the checks that DataValidator support which : 
                1. initial_checks(): don't perform checks cell-wise.
                2. advanced_checks(): perform checks cell-wise.
                3. specific_checks(): provided by user/developer
        advanced_checks() and specific_checks() both generate reports 
        that has cell-wise data for all the cells that failed 
        any of the checks mentioned by the user/developer.
        :return: returns the logs provided by the DataValidator 
        after performing checks, actions and generating logs
        """

        if const.DICT_FUNCTIONS in self.dict:
            self.initial_checks()
            self.advanced_checks()
        if const.DICT_SPECIFIC_CHECKS in self.dict:
            self.specific_checks()

        self.dv.perform_action_and_generate_logs()
        self.report = self.dv.report
        self.logs = self.dv.logs

        return self.logs

    def initial_checks(self):
        """
        These checks are performed on complete DataFrame rather than 
        on particular cells. If the user/developer includes one of the 
        following functions, it is assumed that the file has 
        to pass the test, failing which, exception is raised 
        stopping the validation.
        'functions': {
                        '1st_func_name': {
                            1st_argument_name:  1st_argument,
                            2n_argument_name:   2nd_argument
                        },
                        '2nd_func_name': {
                            1st_argument_name:  1st_argument
                        },
        }
        """
        if const.CHECK_COLUMN_EXISTS in self.dict[const.DICT_FUNCTIONS].keys():
            column_list = self.dict[const.DICT_FUNCTIONS]\
                [const.CHECK_COLUMN_EXISTS][const.COLUMN_LIST]
            if not self.dv.check_column_exists(column_list):
                raise Exception(const.CHECK_COLUMN_EXISTS + const.FAILED)

        if const.CHECK_DUPLICATE_COLUMN in self.dict[const.DICT_FUNCTIONS].keys():
            self.dv.check_duplicate_column()
            if not self.dv.report.duplicate_column_report.empty:
                raise Exception(const.CHECK_DUPLICATE_COLUMN + const.FAILED)

        if const.CHECK_IF_SUBSET in self.dict[const.DICT_FUNCTIONS].keys():
            column_name = self.dict[const.DICT_FUNCTIONS]\
                [const.CHECK_IF_SUBSET][const.COLUMN_NAME]
            check_set = self.dict[const.DICT_FUNCTIONS]\
                [const.CHECK_IF_SUBSET][const.CHECK_SET]
            if not self.dv.check_if_subset(column_name, check_set):
                raise Exception(const.CHECK_IF_SUBSET + const.FAILED)

        if const.CHECK_IF_INTERSECT in self.dict[const.DICT_FUNCTIONS].keys():
            column_name = self.dict[const.DICT_FUNCTIONS]\
                [const.CHECK_IF_INTERSECT][const.COLUMN_NAME]
            check_set = self.dict[const.DICT_FUNCTIONS]\
                [const.CHECK_IF_INTERSECT][const.CHECK_SET]
            if not self.dv.check_if_intersect(column_name, check_set):
                raise Exception(const.CHECK_IF_INTERSECT + const.FAILED)

    def advanced_checks(self):
        """
        These checks are performed cell wise and each function maintains 
        a report that stores the row, column and state of the cell that 
        fails to pass the function.
        
        The data is stored in a global report for each function and 
        is used later by the validate() function to generate an overall
        report and take action according to the actions described 
        by the user/developer.
        
            'functions': {
                        '1st_func_name': {
                            1st_argument_name:  1st_argument,
                            2n_argument_name:   2nd_argument,
                            state:              state
                        },
                        '2nd_func_name': {
                            1st_argument_name:  1st_argument,
                            state:              state
                        },
            }
        
        """

        if const.MISSING_DATA in self.dict[const.DICT_FUNCTIONS].keys():
            self.dv.missing_data()

        if const.DUPLICATE in self.dict[const.DICT_FUNCTIONS].keys():
            list_of_columns = self.dict[const.DICT_FUNCTIONS]\
                [const.DUPLICATE][const.LIST_COLUMNS]
            self.dv.duplicate(list_of_columns)

        if const.NUMERICAL in self.dict[const.DICT_FUNCTIONS].keys():
            column_list = self.dict[const.DICT_FUNCTIONS]\
                [const.NUMERICAL][const.COLUMN_LIST]
            if const.DICT_NUMERICAL_MIN in self.dict[const.DICT_FUNCTIONS]\
                    [const.NUMERICAL]:
                temp_min = self.dict[const.DICT_FUNCTIONS]\
                    [const.NUMERICA][const.DICT_NUMERICAL_MIN]
                self.dv.numerical(column_list, temp_min)
            else:
                self.dv.numerical(column_list)

        if const.CHEMICAL_FORMULA in self.dict[const.DICT_FUNCTIONS].keys():
            column_list = self.dict[const.DICT_FUNCTIONS]\
                [const.CHEMICAL_FORMULA][const.COLUMN_LIST]
            self.dv.chemical_formula(column_list)

        if const.VALUE_IN_CONSTANT in self.dict[const.DICT_FUNCTIONS].keys():
            column_name = self.dict[const.DICT_FUNCTIONS]\
                [const.VALUE_IN_CONSTANT][const.COLUMN_NAME]
            constant_list = self.dict[const.DICT_FUNCTIONS]\
                [const.VALUE_IN_CONSTANT][const.CONSTANT_LIST]
            self.dv.value_in_constant(column_name, constant_list)

        if const.PATTERN_MATCH in self.dict[const.DICT_FUNCTIONS].keys():
            column_name = self.dict[const.DICT_FUNCTIONS]\
                [const.PATTERN_MATCH][const.COLUMN_NAME]
            regex_pattern = self.dict[const.DICT_FUNCTIONS]\
                [const.PATTERN_MATCH][const.REGEX_PATTERN]
            self.dv.value_in_constant(column_name, regex_pattern)

    def specific_checks(self):
        """
        This method applies specific checks provided by the developer 
        in dictionary. The specific_checks section of the dictionary 
        should be of the format :
        'specific_checks' : [
                                {   'function_list': [],
                                        'column_list': []
                                },
                                {   'function_list': [],
                                        'column_list': []
                                },
                            ]
        """
        for func in self.dict[const.DICT_SPECIFIC_CHECKS]:
            func_list = func[const.FUNCTION_LIST]
            col_list = func[const.COLUMN_LIST]
            self.dv.specific_check_for_column(func_list, col_list)
