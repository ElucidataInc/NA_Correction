"""
This module contains some important function which are needed multiple
 number of times during implementation of other functions throughout the
 package.
"""

import os
import re

import pandas as pd
from pyEQL import chemical_formula

import constants


def filter_df(df, parameter):
    """
    This method filters the df according to the parameter passed.
    :param df: df which is to be filtered
    :param parameter: parameter according to which df is to be filtered
    :return: filtered df according to param
    """
    return df.loc[df[constants.COLUMN_STATE] == parameter]


def to_std_report_form(df):
    """
    This function will change the input data-frame to standard data-frame of validation report.
    This is required because some validation can be applied to multiple column but we need
    our report data-frame to be single row column wise. We are using pandas melt to convert it
    to long form from wide form. It is melting the df using 'row_number' and 'column_name'

    for ex: input_df = row_number     Name     Label  Sample
                         0           True     False   True
                         1           False    True    False

            std_df = row_number column_name  state
                            0           Name       True
                            0           Label      False
                            0           Sample     True
                            1           Name       False
                            1           Label      True
                            1           Sample     False

    :return: data-frame in long format
    """
    return pd.melt(df, id_vars=[constants.COLUMN_ROW],
                   var_name=constants.COLUMN_NAME, value_name=constants.COLUMN_STATE)


def check_missing(df):
    """
    This functions check for missing values in a df.
    :param df: data-frame in which missing values is to be checked
    :return: data-frame containing missing value report
    """
    missing_df = df.isnull()
    missing_df[constants.COLUMN_ROW] = missing_df.index
    std_missing_df = to_std_report_form(missing_df)
    filtered_missing_df = filter_df(std_missing_df, True)
    filtered_missing_df[constants.COLUMN_STATE] = constants.MISSING_STATE

    return filtered_missing_df


def get_df(path=None):
    """
    This method returns an data frame from file path or returns an
    empty data frame if no path is passed.
    :return: empty data frame
    """

    # TODO: change function to get_df from path
    if path:
        extension_of_file = get_extension(path)
        return constants.KNOWN_EXTENSION[extension_of_file](path, header=0)
    else:
        return pd.DataFrame()

def check_duplicate_column(file_path):
    """
    This function checks for duplicates in column names
    :param file_path: path of the file to be checked
    :return: dataframe containing all the duplicate columns.
    """
    extension_of_file = get_extension(file_path)
    df = constants.KNOWN_EXTENSION[extension_of_file](file_path, header=None)
    list_of_col = df.iloc[0]
    list_dup_col =check_duplicates_in_list(list_of_col)
    duplicate_col = get_df()
    duplicate_col[constants.COLUMN_NAME] = list_dup_col
    duplicate_col[constants.COLUMN_ROW] = -1
    duplicate_col[constants.COLUMN_STATE] = constants.DUPLICATE_COLUMN_STATE
    return duplicate_col

def check_duplicate_value_in_column(df, list_of_columns):
    """
    This function checks for duplicate value in df column.
    :param df: df for which duplicate value is to be checked
    :param list_of_columns: column name or list of column
    :return: df with column information having duplicate value
    """
    result_df = get_df()
    for column in list_of_columns:
        column_df = get_df()
        column_df[constants.COLUMN_STATE] = df.duplicated(column)
        column_df[constants.COLUMN_NAME] = '-'.join(column)
        column_df[constants.COLUMN_ROW] = column_df.index
        result_df = result_df.append(column_df)

    final_df = filter_df(result_df, True)
    final_df[constants.COLUMN_STATE] = constants.DUPLICATE_STATE
    return final_df


def check_duplicates_in_list(given_list):
    """
    This function checks for duplicates in the given list.
    It iterates over the list and whenever a new element is found, we add that to first_occurence
    :param given_list: 
    :return: duplicate_list :
    """
    first_occurrence = set()
    duplicate_list = set()
    first_occurrence_add = first_occurrence.add
    duplicate_list_add = duplicate_list.add
    for item in given_list:
        if item in first_occurrence:
            duplicate_list_add(item)
        else:
            first_occurrence_add(item)
    return list(duplicate_list)


def check_intensity_value(cell_value, min=0):
    """
    This function checks for intensity value i.e. only numerical value is correct.
    Here we are converting the value to float so if there is any exception we can
    assert that this is becuase it is not numerical and after that we are checking
    if it positive.
    Example : 0.673 --> Correct
              0.as34 --> Invalid
              -0.123 --> Negative
    :param cell_value: value to be checked
    :param min: minimum value of cell
    :return: State
    """

    try:
        value = float(cell_value)
        if value < min:
            return constants.INTENSITY_STATE_NEGATIVE
        else:
            return constants.VALID_STATE
    except ValueError:
        return constants.INTENSITY_STATE_INVALID


def apply_function_column_wise(df, column_list=[], function_list=[]):
    """
       This function apply validation check over column.
       Details:
       This is basically a schema for performing column wise validation checks.
       Validaton functions are passed as an argument. First we are iterating over function
       then for columns. So every column is checked for every function. The nested for is
       required to give the output_df in defined format of ['row_number','column_name,'state']

       for ex:input_df =              Name     Label   Sample1     Sample2
                            0           A         X      0.16        -0.18
                            1           B         Y      -0.15        asa

               if this function is called with parameters:
               column_list =['Sample1','Sample2']
               function = check_intensity_value

               output_df = row_number column_name     state
                             0           Sample2    negative
                             1           Sample1    negative
                             1           Sample2    invalid_value

       :param df: the data frame on which validation is to be applied
       :param column_list: column of data frame on which validation is to be applied
       :param function_list: list of validation function
       :return: resultant df

       TODO: Vectorization can be implemented in more better way.
       """

    resultant_df = get_df()
    for function in function_list:
        column_df = get_df()
        for column in column_list:
            column_df[constants.COLUMN_STATE] = df[column].apply(function)
            column_df[constants.COLUMN_NAME] = column
            column_df[constants.COLUMN_ROW] = column_df.index
            resultant_df = resultant_df.append(column_df)
    output_df = get_df_with_invalid_state(resultant_df)
    return output_df


def get_df_with_invalid_state(df):
    """
    This will return the df containing only invalid states.
    For ex:
    input_df = row_number column_name     state
                  1           label    invalid_label
                  2           label    invalid_label
                  3           label    correct
                  4           label    invalid_label

    output_df = row_number column_name     state
                  1           label    invalid_label
                  2           label    invalid_label
                  4           label    invalid_label

    :param df: input df
    :return: filtered df
    """

    return df.loc[df[constants.COLUMN_STATE] != constants.VALID_STATE]


def check_formula(formula):
    """
    This function check if the formula is chemically valid or not.
    :param formula: cell formula value
    :return: State (ok or invalid formula)
    """
    try:
        if chemical_formula.is_valid_formula(formula.decode('utf-8')):
            return constants.VALID_STATE
        else:
            return constants.FORMULA_INVALID_STATE
    except Exception as e:
        return constants.FORMULA_INVALID_STATE


def check_value_in_list(value, list_of_value):
    """
    This function check if the value is in the list or not
    :param value: value to be checked
    :param list_of_value: list of constant value
    :return: state
    """
    if value in list_of_value:
        return constants.VALID_STATE
    else:
        return constants.VALUE_IN_CONSTANT_INVALID_STATE


def apply_function_column_wise_with_extra_argument(df, column_name, argument, function):
    """
    This is basically a schema for performing column validation using some extra
    argument. The check column is validated with the help of argument passed.
    The resultant data frame is returned which contains state for cell
    which function is applied.

    for ex:input_df =               Name        Label          Formula    Sample1     Sample2
                         0           A     C13N15-label-1-2      C2H6O       0.16        -0.18
                         1           B        C12 PARENT         C2H6O       -0.15        asa
                         2           C       C13-label-5         C2H6O       0.15        0.20

    if this function is called with parameters:
            check_column = Name
            argument = ['A', 'B']
            function = check_value_in_list


            output_df = row_number  column_name          state
                          2            Name        value not found

    :param df: df of which column is to be checked
    :param column_name: name of the column to be checked
    :param argument:extra value needed for validation
    :param function: name of the function to be applied
    :return: df conating invalid row info
    """
    resultant_df = get_df()

    resultant_df[constants.COLUMN_STATE] = df.apply(lambda x: function(x[column_name],
                                                                       argument), axis=1)

    resultant_df[constants.COLUMN_NAME] = column_name
    resultant_df[constants.COLUMN_ROW] = resultant_df.index
    output_df = get_df_with_invalid_state(resultant_df)
    return output_df


def check_pattern(value, pattern):
    """
    This function check if the value is in pattern.
    :param value: value to be checked
    :param pattern: regex pattern
    :return: state valid or state invalid
    """
    regex_pattern = re.compile(pattern)
    if regex_pattern.match(value):
        return constants.VALID_STATE
    else:
        return constants.PATTERN_INVALID_STATE

def get_extension(path):
    """
    This function takes file path and returns the extension of the file.
    :param path: absolute path of the file
    :return: extension of the file as string
    """

    return os.path.splitext(path)[1]


def convert_df_column_to_set(df, column_name):
    """
    This method convert the pandas df column to a python set structure.
    :param df: df
    :param column_name: name of the column
    :return: df[column_name] as set
    """
    return set(list(df[column_name]))


def convert_logs_to_dict(logs):
    """
    Convert logs to dict format.
    :param logs: logs in the form of nested namedtuple
    :return: logs in dict format
    """
    logs_in_dict = dict()
    logs_in_dict[constants.VALIDATION_ERROR] = logs.errors
    logs_in_dict[constants.VALIDATION_WARNING] = dict(logs.warnings._asdict())
    return logs_in_dict