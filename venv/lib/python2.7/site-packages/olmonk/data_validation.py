"""
This module provides utilities for validating data contained in df.
"""
# TODO: Change name of methods as well as variables after user feedback
# TODO: In specific check method try to implement that the callable
# function should be a valid function for validation.

import inspect
import os
import warnings

from action import Action
import constants
import helpers
from report import Report


class DataValidator(object):
    """
    Instances of this class can be configured to run a variety of different
    types of validation check on a data source.
    """

    def __init__(self, file_path, required_columns=[]):
        """
        Instantiate a 'DataValidator', supplying expected 'df' as a
        data source.
        """
        self.check_deprecate()
        self.path = file_path
        self.required_column = required_columns
        self.basic_checks()
        self.report = Report()
        self.logs = None
        self.corrected_df = None

    def check_deprecate(self):
        """
        This function checks whether the instance of this class is
        being created by ConfigDataValidator or not. If not, it shows
        a deprecated warning suggesting not to explicitly create such
        instance.
        """

        warnings.simplefilter(constants.DEPRECATE_ALWAYS, DeprecationWarning)
        if not (inspect.stack()[2][1] == constants.DEPRECATE_CDV_PATH
                and inspect.stack()[2][3] == constants.DEPRECATE_INIT):
            warnings.warn(constants.DV_DEPRECATE, DeprecationWarning)
        warnings.simplefilter(constants.DEPRECATE_IGNORE,DeprecationWarning)


    def basic_checks(self):

        file_path = self.path

        if not os.path.isfile(file_path):
            raise ValueError(file_path + ":" + constants.MSG_PATH_DOESNT_EXIST)
        if not self.check_file_empty():
            raise ValueError(file_path + ":" + constants.MSG_EMPTY_FILE)
        if not self.check_if_convert_to_df():
            raise ValueError(file_path + ":" + constants.MSG_WRONG_FORMAT)
        if not self.check_required_column():
            raise Exception(file_path + ":" + constants.MSG_REQUIRED_COLUMNS_ABSENT)

    def check_file_empty(self):

        """
        This method checks for the file size. We are assuming an empty
        file is of 0 size. It will return false if file is of 0 mb size.
        :param path: Input file path
        :return: Boolean
        """
        try:
            return not os.stat(self.path).st_size == 0
        except:
            return False

    def check_if_convert_to_df(self):
        """
        This method check if the file can convert to pandas df.
        :return: Boolean
        """
        try:
            df = helpers.get_df(self.path)
            self.df = df
            return not df.empty
        except Exception as e:
            # TODO: Implement better catch statement.
            return False

    def check_required_column(self):
        """
        This method checks for required column in a df
        It will return True if all the required columns are present otherwise
        it will return false with list of missing columns.
        :return: Boolean
        """
        if self.required_column:
            required_column_names = self.required_column
            data_frame_columns = [column_name for column_name in list(self.df)]

            missing_columns = [column_name for column_name in required_column_names
                               if column_name not in data_frame_columns]
            self.missing_columns = missing_columns

            if missing_columns:
                return False
            else:
                return True
        else:
            return True

    def check_column_exists(self,column_list):
        """
        This method checks if the given list of columns exist in the dataFrame
        :param: list of columns to be checked. 
        :return: True, if the list exists in the dataFrame. False, if not.
        """
        return set(column_list).issubset(self.df.columns)

    def check_duplicate_column(self):
        """"
        This method checks if there are any duplicate columns in the dataframe
        """
        duplicate_col_report = helpers.check_duplicate_column(self.path)

        self.report.duplicate_column_report = duplicate_col_report

    def check_if_subset(self, column_name, check_set):
        """
        This method check if the column is subset of the set provided.
        :param column_name: name of the column to validate
        :param check_set: set which is needed for validation
        :return: Boolean
        """
        column_values_as_set = helpers.convert_df_column_to_set(self.df, column_name)

        return column_values_as_set.issubset(check_set)

    def check_if_intersect(self, column_name, check_set):
        """
        This method check if the column value has any intersection with check_set
        :param column_name: name of the column to validate
        :param check_set: set which is needed for validation
        :return: Boolean
        """
        column_value_as_set = helpers.convert_df_column_to_set(self.df, column_name)

        if len(column_value_as_set.intersection(check_set)):
            return True
        else:
            return False

    def missing_data(self):
        """
        This method check for missing value in df and save report as
         missing report.
        """
        missing_report = helpers.check_missing(self.df)

        self.report.missing_report = missing_report

    def get_report_df(self):
        """
        This method returns the validation report as data frame.
        """
        return self.report.get_report_df()

    def duplicate(self, list_of_columns):
        """
        This method is to check for a duplicate value in a column or
        in list of column.
        :param list_of_columns: column name or list of column name
        """
        duplicate_report = helpers.check_duplicate_value_in_column(self.df, list_of_columns)
        self.report.duplicate_report = duplicate_report

    def numerical(self, column_list, min=0):
        """
        This method is to check for a numerical value in column. Only numerical
        value which is greater than min is correct.

        # TODO: use min and max value concept.
        :param column_list: column name list
        :param min: minimum value
        """

        numerical_report = helpers.apply_function_column_wise(self.df, column_list,
                                                              [helpers.check_intensity_value])
        self.report.numerical_report = numerical_report

    def chemical_formula(self, column_list):
        """
        This method check for valid chemical formula.
        """
        formula_report = helpers.apply_function_column_wise(self.df, column_list,
                                                            [helpers.check_formula])
        self.report.formula_report = formula_report

    def value_in_constant(self, column_name, constant_list):
        """
        This method check if the column value is in constant value.
        """
        value_in_constant_report = helpers.apply_function_column_wise_with_extra_argument\
                                    (self.df, column_name, constant_list, helpers.check_value_in_list)
        self.report.value_in_constant_report = value_in_constant_report

    def pattern_match(self, column_name, regex_pattern):
        """
        This method is check if the column is in pattern which is passed as an argument.
        The pattern passes is in the form of regex pattern.

        :param column_name: name of column in which pattern check is to be applied
        :param regex_pattern: regex pattern (format) for the column
        """
        pattern_match_report = helpers.apply_function_column_wise_with_extra_argument\
                                (self.df, column_name, regex_pattern, helpers.check_pattern)
        self.report.pattern_match_report = pattern_match_report

    def specific_check_for_column(self, list_of_column, callable_function):
        """
        This method is to check the column for specific check which is not present as general check.
        The specific check function is passed as callable function.
        for ex:
        specific_function(value):
            if value == "specific value"
                return "Valid value"
            else:
                return "Invalid value"

        then we can attach this function to this method by using:
        DataValidator.specific_check(['Sample'], specific_function)

        Arguments:
            :param list_of_column: list of columns name to be checked
            :param specific_function: callable function for specific checks
        """
        specific_check_report = helpers.apply_function_column_wise(self.df, list_of_column,
                                                                   callable_function)
        self.report.specific_check_report = specific_check_report

    def perform_action_and_generate_logs(self, take_action=True):
        """
        This method generate logs and take action on errors and warnings.
        Also it stores the generated logs and corrected df as class
        variable.
        """
        self.report.get_report_df()
        self.report.get_report_in_dict_form()
        action = Action(self.df, self.report, self.required_column)
        action.generate_logs()
        if take_action:
            action.take_action()
            self.logs = helpers.convert_logs_to_dict(action.logs)
            self.corrected_df = action.corrected_df
